package mc.codegen
import mc.utils._
import java.io.{PrintWriter, File}

object CodeGenerator extends Utils {
  val libName = "io"
  def init() = List(
    Symbol("getInt",FunctionType(List(),IntType),CName(libName)),
    Symbol("putInt",FunctionType(List(IntType),VoidType),CName(libName)),
    Symbol("putIntLn",FunctionType(List(IntType),VoidType),CName(libName)),
    Symbol("getFloat",FunctionType(List(),FloatType),CName(libName)),
    Symbol("putFloat",FunctionType(List(FloatType),VoidType),CName(libName)),
    Symbol("putFloatLn",FunctionType(List(FloatType),VoidType),CName(libName)),
    Symbol("putBool",FunctionType(List(BoolType),VoidType),CName(libName)),
    Symbol("putBoolLn",FunctionType(List(BoolType),VoidType),CName(libName)),
    Symbol("putString",FunctionType(List(StringType),VoidType),CName(libName)),
    Symbol("putStringLn",FunctionType(List(StringType),VoidType),CName(libName)),
    Symbol("putLn",FunctionType(List(),VoidType),CName(libName))
  )

  def gen(ast:AST,dir:File) = {

    val gl = init()
    val gc = new CodeGenVisitor(ast,gl,dir)
    gc.visit(ast, null);
  }
}

case class ClassType(cname:String) extends Type

//case class SubContext(emit:Emitter,decl:List[Decl])

case class SubBody(frame:Frame,sym:List[Symbol])

class Access(val frame:Frame,val sym:List[Symbol],val isLeft:Boolean,val isFirst:Boolean)

//editted
case class Symbol(name:String,typ:Type,val valol: Val)
case class FunctionType(input:List[Type],output:Type) extends Type

trait Val
case class Index(value:Int) extends Val
case class CName(value:String) extends Val



class CodeGenVisitor(astTree:AST,env:List[Symbol],dir:File) extends BaseVisitor with Utils {

  val className = "MCClass"
  val path = dir.getPath()
  val emit = new Emitter(path+"/"+className+".j")

  override def visitProgram(ast:Program,c:Any) = {
    emit.printout(emit.emitPROLOG(className, "java.lang.Object"))

    val gloenv:List[Symbol]=ast.decl.foldLeft(env)((x,y)=> {
      if(y.isInstanceOf[VarDecl]){
        val varName=y.asInstanceOf[VarDecl].variable.name
        val varType=y.asInstanceOf[VarDecl].varType
        val sym= Symbol(varName,varType,CName("io"))
        emit.printout(emit.emitATTRIBUTE(varName,varType,false,""))
        sym :: x
      }
      else {
        val funcDecl=y.asInstanceOf[FuncDecl]
        val parTypeLst=funcDecl.param.foldLeft(List[Type]())((x,y)=>x:+y.varType)
        val sym = Symbol(funcDecl.name.name,FunctionType(parTypeLst,funcDecl.returnType),CName(className))
        sym :: x
      }
    })

    val checkFunc=ast.decl.map(x=>if(x.isInstanceOf[FuncDecl]){visit(x,SubBody(null,gloenv))})
    //val checkFunc2=ast.decl.map(x=>if(x.isInstanceOf[FuncDecl]){if(x.asInstanceOf[FuncDecl].name.equals("main"))visit(x,SubBody(null,gloenv))})

    if(ast.decl.exists(x=>{
      if(x.isInstanceOf[VarDecl]) x.asInstanceOf[VarDecl].varType.isInstanceOf[ArrayType]
      else false
    })) genCLINIT(gloenv,new Frame("<clinit>",VoidType))

    // generate default constructor
    genMETHOD(
      FuncDecl(Id("<init>"),List(),null,Block(List(),List())),env,new Frame("<init>",VoidType))
    emit.emitEPILOG()
    c
  }

  def genCLINIT(o:List[Symbol],frame:Frame) ={
    emit.printout(emit.emitMETHOD("<clinit>", FunctionType(List(),VoidType), true, frame))
    frame.enterScope(true);
    emit.printout(emit.emitLABEL(frame.getStartLabel(),frame))
    o.map(x=>{
      if(x.asInstanceOf[Symbol].typ.isInstanceOf[ArrayType]){
        val dimen:Int=x.asInstanceOf[Symbol].typ.asInstanceOf[ArrayType].dimen.value
        val typ:Type=x.asInstanceOf[Symbol].typ.asInstanceOf[ArrayType].eleType
        emit.printout(emit.emitPUSHICONST(dimen,frame)+emit.emitNEWARRAY(typ)+emit.emitPUTSTATIC("MCClass."+x.asInstanceOf[Symbol].name,x.asInstanceOf[Symbol].typ,frame))
      }
    })
    emit.printout(emit.emitLABEL(frame.getEndLabel(),frame))
    emit.printout(emit.emitRETURN(VoidType,frame));
    emit.printout(emit.emitENDMETHOD(frame));
    frame.exitScope();
  }
  /** generate code for default constructor

    *  @param consdecl the function declaration whose code will be generated by this method
    *  @param frame the frame where the initialization happen
    *  @param o the referencing environment
    */
  def genMETHOD(consdecl:FuncDecl,o:List[Symbol],frame:Frame) = {
    val isInit = consdecl.returnType == null
    val isMain = consdecl.name.name.equals("main") && consdecl.param.length == 0 && consdecl.returnType == VoidType
    val returnType = if (isInit) VoidType else consdecl.returnType
    val methodName = if (isInit) "<init>" else consdecl.name.name
    val parTypeList = consdecl.param.map(x=>x.varType)
    val intype = if (isMain) List(ArrayPointerType(StringType)) else parTypeList
    val mtype =  FunctionType(intype,returnType)

    emit.printout(emit.emitMETHOD(methodName, mtype, !isInit, frame))

    frame.enterScope(true);

    val glenv = o

    // Generate code for parameter declarations
    if (isInit) emit.printout(emit.emitVAR(frame.getNewIndex,"this",ClassType(className),frame.getStartLabel,frame.getEndLabel,frame))
    else if (isMain) emit.printout(emit.emitVAR(frame.getNewIndex,"args",ArrayPointerType(StringType),frame.getStartLabel,frame.getEndLabel,frame))
    val envAfterParam={
      if(!isInit && !isMain){
        consdecl.param.map(x=>visit(x,SubBody(frame,glenv)).asInstanceOf[Symbol])
      }
      else{
        List[Symbol]()
      }
    }

    val body = consdecl.body.asInstanceOf[Block]
    val loenv:List[Symbol]= body.decl.foldLeft(envAfterParam)((x,y)=>visit(y,SubBody(frame,x)).asInstanceOf[Symbol]::x)
    emit.printout(emit.emitLABEL(frame.getStartLabel(),frame))

    //Generate code for statements
    if (isInit) {
      emit.printout(emit.emitREADVAR("this",ClassType(className),0,frame))
      emit.printout(emit.emitINVOKESPECIAL(frame))
    }

    //init array
    loenv.map(x=>
      if(x.asInstanceOf[Symbol].typ.isInstanceOf[ArrayType]) {
        val dimen:Int=x.asInstanceOf[Symbol].typ.asInstanceOf[ArrayType].dimen.value
        val typ:Type=x.asInstanceOf[Symbol].typ.asInstanceOf[ArrayType].eleType
        emit.printout(emit.emitPUSHICONST(dimen,frame)+emit.emitNEWARRAY(typ)+emit.emitWRITEVAR(x.asInstanceOf[Symbol].name,x.asInstanceOf[Symbol].typ,x.asInstanceOf[Symbol].valol.asInstanceOf[Index].value,frame))
      })

    val local=loenv++glenv

    body.stmt.map(x=>
      if(x.isInstanceOf[Expr]){
        val result = visit(x,new Access(frame,local,false,true)).asInstanceOf[(String,Type)]
        emit.printout(result._1)
        if(result._2!=VoidType) emit.printout(emit.emitPOP(frame))
      }
      else if(x.isInstanceOf[Return]){
        val result = visit(x, SubBody(frame, local)).asInstanceOf[(String, Type)]
        emit.printout(result._1)
        if(result._2==IntType && returnType==FloatType) emit.printout(emit.emitI2F(frame))
      }
      else {
        val result = visit(x, SubBody(frame, local)).asInstanceOf[(String, Type)]
        emit.printout(result._1)
      }
    )
    emit.printout(emit.emitLABEL(frame.getEndLabel(),frame))
    emit.printout(emit.emitRETURN(returnType,frame));
    emit.printout(emit.emitENDMETHOD(frame));
    frame.exitScope();
  }

  /*FuncDecl(val name: Id, val param: List[VarDecl], val returnType: Type,val body: Stmt)*/
  override def visitFuncDecl(ast:FuncDecl,o:Any) = {
    val subctxt = o.asInstanceOf[SubBody]
    val frame = new Frame(ast.name.name,ast.returnType)
    genMETHOD(ast,subctxt.sym,frame)
  }

  /* Block(val decl: List[Decl], val stmt: List[Stmt])*/
  override def visitBlock(ast:Block,o:Any) ={
    val subctxt = o.asInstanceOf[SubBody]
    val frame= subctxt.frame
    val env=subctxt.sym

    frame.enterScope(false)
    val loenv=ast.decl.foldLeft(env)((x,y)=>visit(y,SubBody(frame,x)).asInstanceOf[Symbol]::x)

    val startLb=emit.emitLABEL(frame.getStartLabel(),frame)

    val str=ast.stmt.foldLeft("")((y,x)=>
      if(x.isInstanceOf[Expr]) {
        val result = visit(x, new Access(frame, loenv, false, true)).asInstanceOf[(String, Type)]
        if (result._2 != VoidType) y+result._1 + emit.emitPOP(frame)
        else y+result._1
      }
      else if(x.isInstanceOf[Return]) {
        val result = visit(x, SubBody(frame, loenv)).asInstanceOf[(String, Type)]
        y+result._1+emit.emitRETURN(result._2,frame)
      }
      else{
        val result = visit(x, SubBody(frame, loenv)).asInstanceOf[(String, Type)]
        y+result._1
      })
    val endLb=emit.emitLABEL(frame.getEndLabel(),frame)
    frame.exitScope()
    (startLb+str+endLb,VoidType)
  }

  /*Dowhile(val sl:List[Stmt],val exp:Expr)*/
  override def visitDowhile(ast:Dowhile,o:Any)={
    val subctxt = o.asInstanceOf[SubBody]
    val frame= subctxt.frame
    val env=subctxt.sym

    frame.enterLoop()
    val brk_lb=frame.getBreakLabel()
    val con_lb=frame.getContinueLabel()
    val rep_lb=frame.getNewLabel()
    val rlb=emit.emitLABEL(rep_lb,frame)
    val list_stmt=ast.sl.foldLeft("")((y,x)=>
      if(x.isInstanceOf[Expr]) {
        val result=visit(x, new Access(frame, env, false, true)).asInstanceOf[(String, Type)]
        if(result._2!=VoidType) y+result._1+emit.emitPOP(frame)
        else y+result._1
      }
      else if(x.isInstanceOf[Return]) {
        val result = visit(x, SubBody(frame, env)).asInstanceOf[(String, Type)]
        y+result._1+ emit.emitRETURN(result._2,frame)
      }
      else{
        val result = visit(x, SubBody(frame, env)).asInstanceOf[(String, Type)]._1
        y + result
      })
    val clb=emit.emitLABEL(con_lb,frame)
    val expr=visit(ast.exp,new Access(frame,env,false,true)).asInstanceOf[(String,Type)]
    val branch_true=emit.emitIFTRUE(rep_lb,frame)
    val brb=emit.emitLABEL(brk_lb,frame)
    frame.exitLoop()

    (rlb+list_stmt+clb+expr._1+branch_true+brb, VoidType)
  }

  /*case class If(val expr: Expr, val thenStmt: Stmt, val elseStmt: Option[Stmt])*/
  override def visitIf(ast:If,o:Any) = {
    val subctxt = o.asInstanceOf[SubBody]
    val frame = subctxt.frame
    val nenv = subctxt.sym

    val expr = visit(ast.expr, new Access(frame, nenv, false, true)).asInstanceOf[(String, Type)]
    val false_lb = frame.getNewLabel()
    val end_lb = frame.getNewLabel()

    val branchfalse = emit.emitIFEQ(false_lb, frame)
    val then_stmt = {
      if (ast.thenStmt.isInstanceOf[Expr]){
        val result=visit(ast.thenStmt, new Access(frame, nenv, false, true)).asInstanceOf[(String, Type)]
        if(result._2!=VoidType) result._1 + emit.emitPOP(frame)
        else result._1
      }
      else if(ast.thenStmt.isInstanceOf[Return]){
        val returnExpr=visit(ast.thenStmt, SubBody(frame, nenv)).asInstanceOf[(String, Type)]
        returnExpr._1 + emit.emitRETURN(returnExpr._2,frame)
      }
      else visit(ast.thenStmt, SubBody(frame, nenv)).asInstanceOf[(String, Type)]._1
    }

    val goTo = emit.emitGOTO(end_lb, frame)
    val flb = emit.emitLABEL(false_lb, frame)

    if (ast.elseStmt.isDefined) {
      val else_stmt = {
        if (ast.elseStmt.get.isInstanceOf[Expr]){
          val result= visit(ast.elseStmt.get, new Access(frame, nenv, false, true)).asInstanceOf[(String, Type)]
          if(result._2!=VoidType) result._1+emit.emitPOP(frame)
          else result._1
        }
        else if(ast.elseStmt.get.isInstanceOf[Return]){
          val returnExpr=visit(ast.elseStmt.get, SubBody(frame, nenv)).asInstanceOf[(String, Type)]
          returnExpr._1 + emit.emitRETURN(returnExpr._2,frame)
        }
        else visit(ast.elseStmt.get, SubBody(frame, nenv)).asInstanceOf[(String, Type)]._1
      }
      val elb = emit.emitLABEL(end_lb, frame)
      (expr._1 + branchfalse + then_stmt + goTo + flb + else_stmt + elb, VoidType)
    }
    else {
      (expr._1 + branchfalse + then_stmt + flb, VoidType)
    }
  }

  /*For(val expr1:Expr,  val expr2: Expr, val expr3: Expr, val loop: Stmt)*/
  override def visitFor(ast: For, o: Any)= {
    val subctxt = o.asInstanceOf[SubBody]
    val frame= subctxt.frame
    val env=subctxt.sym

    frame.enterLoop()
    val brk_lb=frame.getBreakLabel()
    val con_lb=frame.getContinueLabel()
    val rep_lb=frame.getNewLabel()

    val exp1=visit(ast.expr1,new Access(frame, env, false, true)).asInstanceOf[(String,Type)]._1+emit.emitPOP(frame)
    val rlb=emit.emitLABEL(rep_lb,frame)
    val exp2=visit(ast.expr2,new Access(frame, env, false, true)).asInstanceOf[(String,Type)]._1
    val branch_false=emit.emitIFEQ(brk_lb,frame)

    val loop_stmt= {
      if (ast.loop.isInstanceOf[Expr]){
        val result=visit(ast.loop, new Access(frame, env, false, true)).asInstanceOf[(String, Type)]
        if(result._2!=VoidType) result._1+emit.emitPOP(frame)
        else result._1
      }
      else if(ast.loop.isInstanceOf[Return]){
        val returnExpr=visit(ast.loop, SubBody(frame, env)).asInstanceOf[(String, Type)]
        returnExpr._1 + emit.emitRETURN(returnExpr._2,frame)
      }
      else visit(ast.loop, SubBody(frame, env)).asInstanceOf[(String, Type)]._1
    }

    val clb=emit.emitLABEL(con_lb,frame)
    val exp3=visit(ast.expr3,new Access(frame, env, false, true)).asInstanceOf[(String,Type)]._1+emit.emitPOP(frame)
    val brach_rep=emit.emitGOTO(rep_lb,frame)

    val brach_end=emit.emitLABEL(brk_lb,frame)
    frame.exitLoop()

    (exp1+rlb+exp2+branch_false+loop_stmt+clb+exp3+brach_rep+brach_end,VoidType)
  }

  override def visitCallExpr(ast:CallExpr,o:Any) = {
    val ctxt = o.asInstanceOf[Access]
    val frame = ctxt.frame
    val nenv = ctxt.sym
    val sym = lookup(ast.method.name,nenv,(x:Symbol)=>x.name).get.asInstanceOf[Symbol]
    val cname = sym.valol.asInstanceOf[CName].value
    val ctype = sym.typ.asInstanceOf[FunctionType]
    val in:(List[String],List[Type]) = ast.params.foldLeft((List[String](),List[Type]()))((y,x)=> {
      val (str1,typ1) = visit(x,new Access(frame,nenv,false,true)).asInstanceOf[(String,Type)]
      (y._1 :+ str1,y._2 :+ typ1)
    })
    val afterZip=(in._2.zip(ctype.input)).zip(in._1)
    val finalIn=afterZip.foldLeft("")((x,y)=>if(y._1._1==IntType && y._1._2==FloatType)x+y._2+emit.emitI2F(frame) else x+y._2)
    (finalIn+emit.emitINVOKESTATIC(cname+"/"+ast.method.name,ctype,frame),ctype.output)
  }

  override def visitUnaryOp(ast: UnaryOp, o: Any)={
    val ctxt = o.asInstanceOf[Access]
    val frame = ctxt.frame
    val body=visit(ast.body,new Access(frame,ctxt.sym,false,true)).asInstanceOf[(String,Type)]
    if(ast.op=="-"){
      (body._1 + emit.emitNEGOP(body._2,frame), body._2)
    }
    else if(ast.op=="!"){
      (body._1 + emit.emitNOT(body._2,frame), body._2)
    }
  }

  override def visitBinaryOp(ast: BinaryOp, o: Any)={
    val ctxt = o.asInstanceOf[Access]
    val frame = ctxt.frame
    val loenv= ctxt.sym
    if(ast.op=="="){
      val left=visit(ast.left, new Access(frame, ctxt.sym, true, true)).asInstanceOf[(String, Type)]
      val right=visit(ast.right, new Access(frame, ctxt.sym, false, true)).asInstanceOf[(String, Type)]
      if(ast.left.isInstanceOf[Id]) {
        val sym = lookup(ast.left.asInstanceOf[Id].name, loenv, (x: Symbol) => x.name).get
        if (left._2 == right._2){
          if(sym.valol.isInstanceOf[Index])(right._1 + emit.emitDUP(frame) + emit.emitWRITEVAR(sym.name, sym.typ, sym.valol.asInstanceOf[Index].value, frame), left._2)
          else (right._1 + emit.emitDUP(frame) + emit.emitPUTSTATIC("MCClass."+sym.name, sym.typ, frame), left._2)
        }
        else if (left._2 == FloatType && right._2 == IntType){
          if(sym.valol.isInstanceOf[Index])(right._1 + emit.emitI2F(frame) + emit.emitDUP(frame) +emit.emitWRITEVAR(sym.name, sym.typ, sym.valol.asInstanceOf[Index].value, frame), left._2)
          else (right._1 + emit.emitI2F(frame) + emit.emitDUP(frame) + emit.emitPUTSTATIC("MCClass."+sym.name, sym.typ, frame), left._2)
        }
      }
      else if(ast.left.isInstanceOf[ArrayCell]){
        val sym = lookup(ast.left.asInstanceOf[ArrayCell].arr.asInstanceOf[Id].name,loenv,(x: Symbol) => x.name).get
        if(left._2== right._2)(left._1+right._1+emit.emitDUPX2(frame)+emit.emitASTORE(left._2,frame),left._2)
        else if(left._2 == FloatType && right._2 == IntType)(left._1+right._1+emit.emitI2F(frame)+emit.emitDUPX2(frame)+emit.emitASTORE(left._2,frame),left._2)
      }
    }
    else {
      if (ast.op == "+" || ast.op == "-") {
        val left = visit(ast.left, new Access(frame, ctxt.sym, false, true)).asInstanceOf[(String, Type)]
        val right = visit(ast.right, new Access(frame, ctxt.sym, false, true)).asInstanceOf[(String, Type)]
        if (left._2 == right._2) (left._1 + right._1 + emit.emitADDOP(ast.op, left._2, frame), left._2)
        else if (left._2 == IntType && right._2 == FloatType)(left._1 + emit.emitI2F(frame) + right._1 + emit.emitADDOP(ast.op, right._2, frame), right._2)
        else (left._1 + right._1 + emit.emitI2F(frame)+ emit.emitADDOP(ast.op, left._2, frame), left._2)
      }
      else if (ast.op == "*" || ast.op == "/") {
        val left = visit(ast.left, new Access(frame, ctxt.sym, false, true)).asInstanceOf[(String, Type)]
        val right = visit(ast.right, new Access(frame, ctxt.sym, false, true)).asInstanceOf[(String, Type)]
        if (left._2 == right._2) (left._1 + right._1 + emit.emitMULOP(ast.op, left._2, frame), left._2)
        else if (left._2 == IntType && right._2 == FloatType) (left._1 + emit.emitI2F(frame) + right._1 + emit.emitMULOP(ast.op, right._2, frame), right._2)
        else (left._1 + right._1 + emit.emitI2F(frame)+ emit.emitMULOP(ast.op, left._2, frame), left._2)
      }
      else if (ast.op == "%") {
        val left = visit(ast.left, new Access(frame, ctxt.sym, false, true)).asInstanceOf[(String, Type)]
        val right = visit(ast.right, new Access(frame, ctxt.sym, false, true)).asInstanceOf[(String, Type)]
        (left._1 + right._1 + emit.emitMOD(frame), left._2)
      }
      else if(ast.op == "&&"){
        val skip_lb=frame.getNewLabel()
        val left = visit(ast.left, new Access(frame, ctxt.sym, false, true)).asInstanceOf[(String, Type)]._1+emit.emitDUP(frame)
        val brach_skip=emit.emitIFEQ(skip_lb,frame)
        val right= visit(ast.right, new Access(frame, ctxt.sym, false, true)).asInstanceOf[(String, Type)]._1+emit.emitANDOP(frame)
        val slb=emit.emitLABEL(skip_lb,frame)
        (left+brach_skip+right+slb,BoolType)
      }
      else if(ast.op == "||") {
        val skip_lb=frame.getNewLabel()
        val left = visit(ast.left, new Access(frame, ctxt.sym, false, true)).asInstanceOf[(String, Type)]._1+emit.emitDUP(frame)
        val brach_skip=emit.emitIFTRUE(skip_lb,frame)
        val right= visit(ast.right, new Access(frame, ctxt.sym, false, true)).asInstanceOf[(String, Type)]._1+emit.emitOROP(frame)
        val slb=emit.emitLABEL(skip_lb,frame)
        (left+brach_skip+right+slb,BoolType)
      }
      else if(ast.op==">"||ast.op==">="||ast.op=="<"||ast.op=="<="||ast.op=="!="||ast.op=="=="){
        val left = visit(ast.left, new Access(frame, ctxt.sym, false, true)).asInstanceOf[(String, Type)]
        val right = visit(ast.right, new Access(frame, ctxt.sym, false, true)).asInstanceOf[(String, Type)]
        if(left._2==right._2) (left._1 +right._1 + emit.emitREOP(ast.op,left._2,frame), BoolType)
        else if(left._2==FloatType && right._2==IntType)(left._1 +right._1 + emit.emitI2F(frame)+ emit.emitREOP(ast.op,left._2,frame), BoolType)
        else (left._1 +emit.emitI2F(frame)+ right._1 + emit.emitREOP(ast.op,right._2,frame), BoolType)
      }
    }
  }

  override def visitVarDecl(ast:VarDecl,o:Any) = {
    val ctxt = o.asInstanceOf[SubBody]
    val frame = ctxt.frame
    val nenv=ctxt.sym
    val idx=frame.getNewIndex()
    emit.printout(emit.emitVAR(idx,ast.variable.name,ast.varType,frame.getStartLabel,frame.getEndLabel,frame))
    Symbol(ast.variable.name,ast.varType,Index(idx))
  }

  override def visitId(ast:Id, o:Any)={
    val ctxt = o.asInstanceOf[Access]
    val frame = ctxt.frame
    val nenv=ctxt.sym
    val sym:Symbol =lookup(ast.name,nenv,(x:Symbol)=>x.name).get
    if(ctxt.isLeft) ("",sym.typ)
    else{
      if(sym.valol.isInstanceOf[Index]) (emit.emitREADVAR(sym.name,sym.typ,sym.valol.asInstanceOf[Index].value,frame),sym.typ)
      else (emit.emitGETSTATIC("MCClass."+sym.name,sym.typ,frame),sym.typ)
    }
  }

  /*case class ArrayCell(arr: Expr, idx: Expr) extends LHS {*/
  override def visitArrayCell(ast: ArrayCell, o: Any)= {
    val ctxt = o.asInstanceOf[Access]
    val frame = ctxt.frame
    val nenv = ctxt.sym
    if (ast.arr.isInstanceOf[Id] ) {
      val sym: Symbol = lookup(ast.arr.asInstanceOf[Id].name, nenv, (x: Symbol) => x.name).get
      if (sym.valol.isInstanceOf[Index]) {
        val readVar = emit.emitREADVAR(sym.name, sym.typ, sym.valol.asInstanceOf[Index].value, frame)
        if (sym.typ.isInstanceOf[ArrayType]) {
          if (ctxt.isLeft) (readVar + visit(ast.idx, new Access(frame, nenv, false, true)).asInstanceOf[(String, Type)]._1, sym.typ.asInstanceOf[ArrayType].eleType)
          else (readVar + visit(ast.idx, new Access(frame, nenv, false, true)).asInstanceOf[(String, Type)]._1 + emit.emitALOAD(sym.typ.asInstanceOf[ArrayType].eleType, frame), sym.typ.asInstanceOf[ArrayType].eleType)
        }
        else {
          if (ctxt.isLeft) (readVar + visit(ast.idx, new Access(frame, nenv, false, true)).asInstanceOf[(String, Type)]._1, sym.typ.asInstanceOf[ArrayPointerType].eleType)
          else (readVar + visit(ast.idx, new Access(frame, nenv, false, true)).asInstanceOf[(String, Type)]._1 + emit.emitALOAD(sym.typ.asInstanceOf[ArrayPointerType].eleType, frame), sym.typ.asInstanceOf[ArrayPointerType].eleType)
        }
      }
      else {
        val readStatic = emit.emitGETSTATIC("MCClass." + sym.name, sym.typ, frame)
        if (ctxt.isLeft) (readStatic + visit(ast.idx, new Access(frame, nenv, false, true)).asInstanceOf[(String, Type)]._1, sym.typ.asInstanceOf[ArrayType].eleType)
        else (readStatic + visit(ast.idx, new Access(frame, nenv, false, true)).asInstanceOf[(String, Type)]._1 + emit.emitALOAD(sym.typ.asInstanceOf[ArrayType].eleType, frame), sym.typ.asInstanceOf[ArrayType].eleType)
      }
    }
    else {
      val funcReturn = visit(ast.arr, new Access(frame, nenv, false, true)).asInstanceOf[(String, Type)]
      (funcReturn._1 + visit(ast.idx, new Access(frame, nenv, false, true)).asInstanceOf[(String, Type)]._1 + emit.emitALOAD(funcReturn._2.asInstanceOf[ArrayPointerType].eleType,frame), funcReturn._2)
    }
  }

  override def visitReturn(ast:Return, o:Any) ={
    val ctxt = o.asInstanceOf[SubBody]
    val frame =ctxt.frame
    ast.expr match{
      case Some(result)=> visit(result,new Access(frame,ctxt.sym,false,true)).asInstanceOf[(String,Type)]
      case _ => ("",VoidType)
    }
  }

  override def visitBreak(ast:Break.type , o:Any)={
    val ctxt = o.asInstanceOf[SubBody]
    val frame =ctxt.frame
    val brklb=frame.getBreakLabel()
    (emit.emitGOTO(brklb,frame),VoidType)
  }

  override def visitContinue(ast:Continue.type , o:Any)={
    val ctxt = o.asInstanceOf[SubBody]
    val frame =ctxt.frame
    val conlb=frame.getContinueLabel()
    (emit.emitGOTO(conlb,frame),VoidType)
  }

  override def visitIntLiteral(ast:IntLiteral,o:Any) = {
    val ctxt = o.asInstanceOf[Access]
    val frame = ctxt.frame
    (emit.emitPUSHCONST(ast.value.toString,IntType,frame),IntType)
  }

  override def visitFloatLiteral(ast: FloatLiteral, o: Any) ={
    val ctxt = o.asInstanceOf[Access]
    val frame = ctxt.frame
    (emit.emitPUSHCONST(ast.value.toString,FloatType,frame), FloatType)
  }

  override def visitBooleanLiteral(ast: BooleanLiteral, o: Any) ={
    val ctxt = o.asInstanceOf[Access]
    val frame = ctxt.frame
    (emit.emitPUSHCONST(ast.value.toString,BoolType,frame), BoolType)
  }

  override def visitStringLiteral(ast: StringLiteral, o: Any)={
    val ctxt = o.asInstanceOf[Access]
    val frame = ctxt.frame
    (emit.emitPUSHCONST("\""+ast.value+"\"",StringType,frame), StringType)
  }
}

